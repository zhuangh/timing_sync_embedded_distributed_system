%%% Template originaly created by Karol KozioÅ‚ (mail@karol-koziol.net) and modified for ShareLaTeX use
\documentclass[a4paper,12pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{url}
\usepackage[tx]{sfmath}
\renewcommand\familydefault{\sfdefault}
\usepackage{tgheros}

\usepackage{amsmath,amssymb,amsthm,textcomp}
\usepackage{enumerate}
\usepackage{multicol}
\usepackage{tikz}
\usepackage{comment}
\usepackage{geometry}
%\geometry{total={210mm,297mm}, left=20mm,right=20mm, bindingoffset=0mm, top=25mm,bottom=25mm}
\geometry{left=0.5in,right=0.5in, top=0.5in, bottom=0.7in}


\linespread{1.3}

\newcommand{\linia}{\rule{\linewidth}{0.5pt}}

% custom theorems if needed
\newtheoremstyle{mytheor}
{1ex}{1ex}{\normalfont}{0pt}{\scshape}{.}{1ex}
{{\thmname{#1 }}{\thmnumber{#2}}{\thmnote{ (#3)}}}

\theoremstyle{mytheor}
\newtheorem{defi}{Definition}

% my own titles
\makeatletter
\renewcommand{\maketitle}{
	\begin{center}
	%	\vspace{2ex}
		{\Large {\@title}}
	 	\vspace{1ex}
	%	\\	
	\\
	\centering \@author \\
  \@date
	%	\linia\\
	  \vspace{-0.3cm}%4ex}
	\end{center}
}
\makeatother
%%%

% custom footers and headers
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{}
\lfoot{Final Project}
\cfoot{}
\rfoot{Page \thepage}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
%

% all section titles centered and bolded
\usepackage{sectsty}
%\allsectionsfont{\centering\bfseries\large}

\allsectionsfont{\bfseries\large}
%
% add section label
\renewcommand\thesection{\arabic{section}}
%

%%%----------%%%----------%%%----------%%%----------%%%

\begin{document}
	
\title{CSE 237B Final Project \\ Google Go Programming Language and Real-Time Applications} 
    
\author{Hao Zhuang, hao.zhuang@cs.ucsd.edu, CSE Dept., UC San Diego\\
Xinan Wang, xinan@ucsd.edu, CSE Dept., UC San Diego}
 
\maketitle 
\vspace{0.1in} 

 
\section{Introduction} 

In this project, we implement XBee transportation among BeagleBone Black (BBB) devices.
First, we implement the communication.
Then, we create environment to mimic a heavy communication traffic. We anticipate the overhead from timer implemented by pure Go programming language.  
Then, we improve the timer by using lower-level C programming language, which is more closed to hardware-level. 

\section{Settings}
\subsection{Setting A} 

We have two BeagleBone Black (BBB) \cite{bbb} devices with XBee Xsticks on each. 
\begin{itemize} 
\item  One of machine is set as Coordinate AT (CAT), the other is END Device AT(EAT). 
\item  Use xctu \cite{xctu} from Digi to set the Xstick. The baud rate is $9600$. 
\item  Use 
``stty -F /dev/ttyUSB0 speed 9600 cs8 -cstopb crtscts -parenb raw  ''
at each device  for the serial communication in Linux at BBB. 
\item 
The communication programs are implemented in Go language \cite{go}.
\item 
The timer directly utilizes Go's Time library \cite{gotimer}.  
\end{itemize} 

\subsection{Setting B}
Build on the Setting A, we further create a busy distributed application.  
The hardware level timer implementation is done using C API \cite{fang} \cite{libcgo} and invoked by Go. The main functions we call as follows,
\begin{itemize}
\item  Set timer "timerfd\_settime(timerfd, 0, \&new\_value, NULL) == -1"
\item  Create timer "timerfd\_create(CLOCK\_MONOTONIC, 0)"; 
\item  Invoke from sleeping mode by "read(timerfd, \&exp, sizeof(uint64\_t))"
\end{itemize}

We assume 



\section{Implementation of communication program and the benchmark for characterization of time latency/jitter} 

In this work, we profile the latency/jitter from stack of Xbee (ZigBee) communication stack up to Golang Runtime. I also devise a tiny benchmark for Go's timer in order to capture more accurate result by removing its overhead on the top of OS.

\subsection{Design} 

The flow of my benchmark is listed as follow:
\vspace{-0.1in}
\begin{itemize} 
\item Coordinate AT (CAT): {\bf xbeeTimingRecvCor.go}, {\bf xbeeTimingSend.go} and {\bf Go's serial package} \cite{goserial}, which are under CoordinateAT in my tar package. 
\item END Device AT (EAT): {\bf xbeeTimingRecv.go} and {\bf Go's serial package} \cite{goserial}, which are under EndDeviceAT in my tar package. 
\end{itemize} 
\vspace{0.1in}

\noindent {\bf Flow of benchmark}
\begin{itemize}  
	\label{comm} 
	\item[1.] First, launch  {\bf xbeeTimingRecv.go} at EAT, which waits for the time stamp sent from CAT (After {\bf Item 3}, once it receives the time stamp, it immediately returns to CAT).  
	\item[2.] Then, Launch {\bf xbeeTimingRecvCor.go} at CAT. (It receives the time stamp back from {\bf Item 1}, subtracts it from current time and obtain the round trip time number (RTT). It keeps receiving the data to profile the delay/jitter number.)	 
	\item[3.] Launch {\bf xbeeTimingSend.go} at CAT to send the time stamps  every 15 seconds.  
\end{itemize}
The code can be found in the submitted tar package correspondingly. 

\vspace{0.1in}
 

\subsection{Data and Observations}
 
The time latency contains from Xbee (ZigBee) communication stack up to Golang runtime performance.  Table \ref{tab:rtt} shows the data obtained by the benchmark.

\begin{table}[h]
	\centering
%	\small
{
	\caption{
		{Characterizations of Latency/Jitter of Xbee (ZigBee) communication and Golang Runtime (the time stamps are from the system date of BeagleBone Black {\bf Coordinate AT}).} 
	}
	%\vspace{0.1in}
 		\begin{tabular}{|r|c|c|r||r|}
 				\hline 
 		Test & TimeStamp Sent & TimeStamp Received & RTT($\mu s$) & delay ($\mu s)$ \\ \hline   			\hline 
   	1&	23:APR:2014:23:16:07:720864	& 23:APR:2014:23:16:08:342818 &	621954&	310977.0  \\ \hline 
 	2&	 23:APR:2014:23:16:22:728927&	23:APR:2014:23:16:23:312285	& 583358&	291679.0  \\ \hline 
 	3&	 23:APR:2014:23:16:37:732581&	23:APR:2014:23:16:38:346838	& 614257&	307128.5 \\ \hline 
 	4	& 23:APR:2014:23:16:52:737204&	23:APR:2014:23:16:53:303785 & 566581&	283290.5 \\ \hline 
 	5&	 23:APR:2014:23:17:07:742727&	23:APR:2014:23:17:08:374429 & 631702&	315851.0 \\ \hline 
 	6	& 23:APR:2014:23:17:22:747460&	23:APR:2014:23:17:23:318574 & 571114&	285557.0 \\ \hline 
 	7	& 23:APR:2014:23:17:37:750225&	23:APR:2014:23:17:38:374054	& 623829&	311914.5 \\ \hline 
 	8&	 23:APR:2014:23:17:52:753309&	23:APR:2014:23:17:53:314487 & 561178&	280589.0 \\ \hline 
 	9	& 23:APR:2014:23:18:07:765073&	23:APR:2014:23:18:08:377745	& 612672&	306336.0 \\ \hline 
		\end{tabular} 
	\label{tab:rtt}
}
\end{table}

Based on the limited data set, 
the {\bf average delay} is {\bf $0.299258s$}. 
The {\bf  maximum delay   $0.315851s$} and the {\bf minimum delay   $0.280589s$}.
% We assume the number should be around $0.016593s  \sim 0.018669s$. 
The jitter is $0.035262s$.
The statistics is shown in Table \ref{tab:rtt}. 		

\begin{table}[h]
	\centering
	\small{
		\caption{The statistics of Table \ref{tab:rtt}} \vspace{0.1in}
		\begin{tabular}{|c|r|}  \hline 
			Average Delay & 	$0.299258s$ \\ \hline 
			Jitter & $0.035262s$ \\ \hline 
			Maximum Delay &  $0.315851s$  \\ \hline 
			Minimum Delay &  $0.280589s$ \\ \hline 
		\end{tabular}
		% \begin{tablenotes}\scriptsize
		%	\item [1] Speedup of I-MATEX (mn) over TR ($h=10ps$) 
		%	\item [2] Speedup of R-MATEX (mn)over I-MATEX (mn) 
		%	\item [3] Speedup of R-MATEX (mn) over TR ($h=10ps$)
		%	\item [4] Speedup of R-MATEX (mn) over TR (adpt)      
		%	\vspace{-0.5in}
		%    \end{tablenotes} 
		\label{tab:sum}
	}
\end{table}		


\vspace{0.1in}
%\noindent {\bf
\subsection{Tiny Benchmark for the characterization  of Golang timer overhead on the top of the OS-level} 
\label{timer}

The procedure is: 

 At each iteration, I issue two timer using Go's time.Now, between the two timer, there is $5s$ sleep by Go's time.Sleep. I repeat this process by 10 times and obtain $50008918967ns$. 

I subtract $50s$ ($10 \times 5s$) from $50.008918967s$, and divide it by $10$. The result $0.0008918967s$ is the overhead by using Golang timer OS-level. 


\vspace{0.1in}
%\noindent {\bf 
\subsection{More accurate Delay/Jitter number without Golang timer overhead} 

From Sec. \ref{timer}, we can have more accurate profiles about the Xbee communication stacks on BBB up to the Golang runtime. 

Since I send the time stamp after the timer at CAT side, and invoke another timer after  receiving time stamp, there are two units of the overhead there. 
To be more accurate, I need to subtract the delay by $0.001784s$ ($\approx 2\times 0.0008918967s$). Therefore, 
We have another Table \ref{tab:sum1} to calculate the delay/jitter by removing the timer overhead in Go. (The benchmark is designed in {\bf  golang\_timer\_overhead.go} in my tar package). 


\begin{table}[h]
	\centering
	\small{
		\caption{The statistics of Table \ref{tab:rtt} without Golang Timer Overhead}
		 \vspace{0.1in}
		\begin{tabular}{|c|r|}  \hline 
			Average Delay & 	$0.297474s$ \\ \hline 
			Jitter 		  & 	$0.035262s$ \\ \hline 
			Maximum Delay &  	$0.314067s$  \\ \hline 
			Minimum Delay &  	$0.278805s$ \\ \hline 
		\end{tabular}
		% \begin{tablenotes}\scriptsize
		%	\item [1] Speedup of I-MATEX (mn) over TR ($h=10ps$) 
		%	\item [2] Speedup of R-MATEX (mn)over I-MATEX (mn) 
		%	\item [3] Speedup of R-MATEX (mn) over TR ($h=10ps$)
		%	\item [4] Speedup of R-MATEX (mn) over TR (adpt)      
		%	\vspace{-0.5in}
		%    \end{tablenotes} 
		\label{tab:sum1}
	}
\end{table}		
 
\subsection{Other Founding}

Use cat ``/dev/ttyUSB0'' and ``echo "XXX" > /dev/ttyUSB0'' to communicate via XBee, where XXX is any string.  
\begin{itemize} 
\item The data sent from End Device AT to Coordinate AT is good.   
\item The data sent from Coordinate AT to End Device AT often loses message. Or Coordinate AT not response at the side of  Coordinate AT. 
\end{itemize} 
This leads to the workaround in this report. I use a running pool at both of CAT and EAT and another program to inject the time stamp. In this way, the messages are pretty reliable and almost never miss a byte. 


\section{Summary}

I implement the message communication programs via Go in BeagleBone Black boards with Xbee (Xstick). All the programs, including the public serial package of Go \cite{goserial}, are included in the attachment. The programs can be simply copied to two configured BeagleBone Black boards correspondingly, and launched to communicate as discussed in Sec. \ref{comm}. 
The benchmarks profile the round trip time, delay and jitter when the two BeagleBone Black boards communicated via Xbee. 
I think the above report and code can achieve the main goal of Lab 2. 
I can do more profiling when there is enough time.


%\section{Acknowledgment}



\bibliographystyle{ieeetr}

\bibliography{ref} 

 
\end{document}
